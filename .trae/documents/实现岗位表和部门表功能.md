# 实现支持Materialized Path树状结构的部门表和岗位表功能

## 1. 设计核心概念

### Materialized Path树状结构
Materialized Path是一种树状结构存储方式，每个节点存储从根节点到自身的完整路径，如`/0/1/2`，用于高效查询子树和深度。

### 设计要点
1. **路径生成**：自动生成和维护节点路径
2. **子树查询**：支持高效查询所有子节点
3. **深度计算**：通过路径长度计算节点深度
4. **节点移动**：支持节点移动时更新所有子节点路径
5. **完整性维护**：确保路径的完整性和正确性

## 2. 更新数据库schema文件

在`docs/database_schema.sql`中添加以下表结构：

### 部门表(sys_dept)
```sql
-- 部门表，支持Materialized Path树状结构
CREATE TABLE IF NOT EXISTS sys_dept (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '部门ID',
    name VARCHAR(50) NOT NULL COMMENT '部门名称，如“财务部”',
    parent_id BIGINT NULL COMMENT '父部门ID，NULL表示根部门',
    path VARCHAR(255) NOT NULL COMMENT 'Materialized Path，如“/0/1/101”，用于高效查询子树',
    depth INT NOT NULL COMMENT '深度，根部门为0，子部门+1',
    sort_order INT DEFAULT 0 NULL COMMENT '部门顺序，用于排序',
    leader_id BIGINT NULL COMMENT '部门负责人ID，关联员工表',
    status VARCHAR(20) DEFAULT 'ACTIVE' NOT NULL COMMENT '状态：ACTIVE（启用）、INACTIVE（停用）',
    create_by VARCHAR(64) NULL COMMENT '创建者ID，user_id:varchar(64)',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP NULL COMMENT '创建时间',
    update_by VARCHAR(64) NULL COMMENT '更新者ID，user_id:varchar(64)',
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_dept_parent (parent_id),
    INDEX idx_dept_path (path),
    INDEX idx_dept_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='部门表，支持Materialized Path树状结构';
```

### 岗位表(sys_position)
```sql
-- 岗位表
CREATE TABLE IF NOT EXISTS sys_position (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '主键ID',
    position_code VARCHAR(64) UNIQUE NOT NULL COMMENT '岗位编码',
    category_code VARCHAR(64) NOT NULL COMMENT '类别编码',
    position_name VARCHAR(128) NOT NULL COMMENT '岗位名称',
    department VARCHAR(64) NOT NULL COMMENT '部门',
    order_num INT DEFAULT 0 COMMENT '排序',
    level VARCHAR(32) COMMENT '职级，如"P3"',
    status BOOLEAN DEFAULT TRUE NOT NULL COMMENT '状态',
    create_by VARCHAR(64) NOT NULL COMMENT '创建者',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL COMMENT '创建时间',
    update_by VARCHAR(64) NOT NULL COMMENT '更新者',
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL COMMENT '更新时间',
    remark VARCHAR(500) COMMENT '备注',
    INDEX idx_position_code (position_code),
    INDEX idx_category_code (category_code),
    INDEX idx_position_status (status),
    INDEX idx_position_department (department)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='岗位表';
```

## 3. 更新RBAC模型

在`app/models/rbac.py`中添加以下内容：

### SQLAlchemy模型
```python
class SysDept(Base):
    """部门表，支持Materialized Path树状结构"""
    __tablename__ = "sys_dept"

    id = Column(Integer, primary_key=True, autoincrement=True, comment="部门ID")
    name = Column(String(50), nullable=False, comment="部门名称")
    parent_id = Column(Integer, nullable=True, comment="父部门ID")
    path = Column(String(255), nullable=False, comment="Materialized Path")
    depth = Column(Integer, nullable=False, comment="深度")
    sort_order = Column(Integer, default=0, comment="部门顺序")
    leader_id = Column(Integer, nullable=True, comment="部门负责人ID")
    status = Column(String(20), default="ACTIVE", nullable=False, comment="状态")
    create_by = Column(String(64), nullable=True, comment="创建者ID")
    create_time = Column(DateTime, default=func.now(), comment="创建时间")
    update_by = Column(String(64), nullable=True, comment="更新者ID")
    update_time = Column(DateTime, default=func.now(), onupdate=func.now(), comment="更新时间")

    def __repr__(self):
        return f"<SysDept(id={self.id}, name='{self.name}', path='{self.path}', depth={self.depth})>"


class SysPosition(Base):
    """岗位表"""
    __tablename__ = "sys_position"

    id = Column(Integer, primary_key=True, autoincrement=True, comment="主键ID")
    position_code = Column(String(64), unique=True, nullable=False, comment="岗位编码")
    category_code = Column(String(64), nullable=False, comment="类别编码")
    position_name = Column(String(128), nullable=False, comment="岗位名称")
    department = Column(String(64), nullable=False, comment="部门")
    order_num = Column(Integer, default=0, comment="排序")
    level = Column(String(32), comment="职级")
    status = Column(Boolean, default=True, nullable=False, comment="状态")
    create_by = Column(String(64), nullable=False, comment="创建者")
    create_time = Column(DateTime, default=func.now(), comment="创建时间")
    update_by = Column(String(64), nullable=False, comment="更新者")
    update_time = Column(DateTime, default=func.now(), onupdate=func.now(), comment="更新时间")
    remark = Column(String(500), comment="备注")

    def __repr__(self):
        return f"<SysPosition(id={self.id}, position_code='{self.position_code}', position_name='{self.position_name}')>"
```

### Pydantic模型
```python
# 部门相关模型
class DeptBase(BaseModel):
    """部门基础模型"""
    name: str = Field(..., description="部门名称", max_length=50)
    parent_id: Optional[int] = Field(None, description="父部门ID")
    sort_order: int = Field(0, description="部门顺序")
    leader_id: Optional[int] = Field(None, description="部门负责人ID")
    status: str = Field("ACTIVE", description="状态")


class DeptCreate(DeptBase):
    """创建部门请求模型"""
    create_by: str = Field(..., description="创建者", max_length=64)
    update_by: str = Field(..., description="更新者", max_length=64)


class DeptUpdate(BaseModel):
    """更新部门请求模型"""
    name: Optional[str] = Field(None, description="部门名称", max_length=50)
    parent_id: Optional[int] = Field(None, description="父部门ID")
    sort_order: Optional[int] = Field(None, description="部门顺序")
    leader_id: Optional[int] = Field(None, description="部门负责人ID")
    status: Optional[str] = Field(None, description="状态")
    update_by: str = Field(..., description="更新者", max_length=64)


class DeptResponse(DeptBase, BaseResponse):
    """部门响应模型"""
    path: str = Field(..., description="Materialized Path")
    depth: int = Field(..., description="深度")
    children: List["DeptResponse"] = Field(default_factory=list, description="子部门列表")

    class Config:
        from_attributes = True


# 岗位相关模型
class PositionBase(BaseModel):
    """岗位基础模型"""
    position_code: str = Field(..., description="岗位编码", max_length=64)
    category_code: str = Field(..., description="类别编码", max_length=64)
    position_name: str = Field(..., description="岗位名称", max_length=128)
    department: str = Field(..., description="部门", max_length=64)
    order_num: int = Field(0, description="排序")
    level: Optional[str] = Field(None, description="职级", max_length=32)
    status: bool = Field(True, description="状态")
    remark: Optional[str] = Field(None, description="备注", max_length=500)


class PositionCreate(PositionBase):
    """创建岗位请求模型"""
    create_by: str = Field(..., description="创建者", max_length=64)
    update_by: str = Field(..., description="更新者", max_length=64)


class PositionUpdate(BaseModel):
    """更新岗位请求模型"""
    category_code: Optional[str] = Field(None, description="类别编码", max_length=64)
    position_name: Optional[str] = Field(None, description="岗位名称", max_length=128)
    department: Optional[str] = Field(None, description="部门", max_length=64)
    order_num: Optional[int] = Field(None, description="排序")
    level: Optional[str] = Field(None, description="职级", max_length=32)
    status: Optional[bool] = Field(None, description="状态")
    remark: Optional[str] = Field(None, description="备注", max_length=500)
    update_by: str = Field(..., description="更新者", max_length=64)


class PositionResponse(PositionBase, BaseResponse):
    """岗位响应模型"""
    pass
```

## 4. 实现Materialized Path核心功能

在`app/db/rbac_dao.py`中添加以下核心功能：

### 路径生成和维护
```python
@staticmethod
def _generate_path(db: Session, parent_id: Optional[int]) -> tuple:
    """生成Materialized Path
    
    Args:
        db: 数据库会话
        parent_id: 父部门ID
        
    Returns:
        tuple: (path, depth)
    """
    if parent_id is None:
        # 根部门
        return ("/0", 0)
    
    parent_dept = db.query(SysDept).filter(SysDept.id == parent_id).first()
    if not parent_dept:
        raise ValueError(f"父部门ID {parent_id} 不存在")
    
    # 生成新路径，格式为 /父路径/新ID
    new_path = f"{parent_dept.path}/{parent_id}"
    return (new_path, parent_dept.depth + 1)


@staticmethod
def _update_descendant_paths(db: Session, old_path: str, new_path: str, old_depth: int, new_depth: int):
    """更新所有子节点的路径和深度
    
    Args:
        db: 数据库会话
        old_path: 旧路径
        new_path: 新路径
        old_depth: 旧深度
        new_depth: 新深度
    """
    # 查找所有子节点（路径以旧路径开头）
    descendants = db.query(SysDept).filter(
        SysDept.path.like(f"{old_path}/%"),
        SysDept.depth > old_depth
    ).all()
    
    for dept in descendants:
        # 计算新路径：替换开头的旧路径为新路径
        dept.path = dept.path.replace(old_path, new_path, 1)
        # 计算新深度：调整深度差
        dept.depth = new_depth + (dept.depth - old_depth)
    
    if descendants:
        db.commit()
```

### 部门相关CRUD方法
```python
@staticmethod
def create_dept(db: Session, dept_data: dict) -> SysDept:
    """创建部门，自动生成Materialized Path"""
    # 生成路径和深度
    parent_id = dept_data.get("parent_id")
    path, depth = RbacDao._generate_path(db, parent_id)
    
    # 添加路径和深度信息
    dept_data["path"] = path
    dept_data["depth"] = depth
    
    dept = SysDept(**dept_data)
    db.add(dept)
    db.commit()
    db.refresh(dept)
    return dept


@staticmethod
def update_dept(db: Session, dept_id: int, update_data: dict) -> Optional[SysDept]:
    """更新部门，处理父部门变更时的路径更新"""
    dept = db.query(SysDept).filter(SysDept.id == dept_id).first()
    if not dept:
        return None
    
    old_path = dept.path
    old_depth = dept.depth
    old_parent_id = dept.parent_id
    
    # 如果父部门变更，需要更新路径
    if "parent_id" in update_data and update_data["parent_id"] != old_parent_id:
        # 生成新路径和深度
        new_path, new_depth = RbacDao._generate_path(db, update_data["parent_id"])
        update_data["path"] = new_path
        update_data["depth"] = new_depth
    
    # 更新部门信息
    for key, value in update_data.items():
        if hasattr(dept, key):
            setattr(dept, key, value)
    
    db.commit()
    db.refresh(dept)
    
    # 如果父部门变更，更新所有子节点的路径和深度
    if "parent_id" in update_data and update_data["parent_id"] != old_parent_id:
        RbacDao._update_descendant_paths(db, old_path, dept.path, old_depth, dept.depth)
    
    return dept


@staticmethod
def get_dept_by_id(db: Session, dept_id: int) -> Optional[SysDept]:
    """根据ID获取部门"""
    return db.query(SysDept).filter(SysDept.id == dept_id).first()


@staticmethod
def get_all_depts(db: Session) -> List[SysDept]:
    """获取所有部门"""
    return db.query(SysDept).order_by(SysDept.path).all()


@staticmethod
def get_dept_tree(db: Session) -> List[SysDept]:
    """获取部门树结构"""
    return db.query(SysDept).order_by(SysDept.path).all()


@staticmethod
def get_descendants(db: Session, dept_id: int) -> List[SysDept]:
    """获取指定部门的所有子节点（Materialized Path高效查询）"""
    dept = db.query(SysDept).filter(SysDept.id == dept_id).first()
    if not dept:
        return []
    
    # 使用LIKE查询所有子节点，Materialized Path的核心优势
    return db.query(SysDept).filter(
        SysDept.path.like(f"{dept.path}/%"),
        SysDept.depth > dept.depth
    ).order_by(SysDept.path).all()


@staticmethod
def get_ancestors(db: Session, dept_id: int) -> List[SysDept]:
    """获取指定部门的所有父节点"""
    dept = db.query(SysDept).filter(SysDept.id == dept_id).first()
    if not dept:
        return []
    
    # 解析路径，获取所有父节点ID
    path_parts = dept.path.split("/")[1:-1]  # 排除首尾空字符串和自身ID
    if not path_parts:
        return []
    
    ancestor_ids = [int(part) for part in path_parts]
    return db.query(SysDept).filter(
        SysDept.id.in_(ancestor_ids)
    ).order_by(SysDept.depth).all()


@staticmethod
def delete_dept(db: Session, dept_id: int) -> bool:
    """删除部门"""
    # 检查是否有子部门
    descendants = RbacDao.get_descendants(db, dept_id)
    if descendants:
        raise ValueError("该部门存在子部门，无法删除")
    
    dept = db.query(SysDept).filter(SysDept.id == dept_id).first()
    if dept:
        db.delete(dept)
        db.commit()
        return True
    return False
```

## 5. 更新RBAC Service

在`app/services/rbac_service.py`中添加以下方法：

### 部门相关服务方法
```python
@staticmethod
def create_dept(db: Session, dept_data: Dict[str, Any]) -> SysDept:
    """创建部门"""
    return RbacDao.create_dept(db, dept_data)


@staticmethod
def update_dept(db: Session, dept_id: int, update_data: Dict[str, Any]) -> Optional[SysDept]:
    """更新部门"""
    return RbacDao.update_dept(db, dept_id, update_data)


@staticmethod
def get_dept_by_id(db: Session, dept_id: int) -> Optional[SysDept]:
    """根据ID获取部门"""
    return RbacDao.get_dept_by_id(db, dept_id)


@staticmethod
def get_all_depts(db: Session) -> List[SysDept]:
    """获取所有部门"""
    return RbacDao.get_all_depts(db)


@staticmethod
def get_dept_tree(db: Session) -> List[SysDept]:
    """获取部门树结构"""
    return RbacDao.get_dept_tree(db)


@staticmethod
def get_dept_descendants(db: Session, dept_id: int) -> List[SysDept]:
    """获取指定部门的所有子节点"""
    return RbacDao.get_descendants(db, dept_id)


@staticmethod
def get_dept_ancestors(db: Session, dept_id: int) -> List[SysDept]:
    """获取指定部门的所有父节点"""
    return RbacDao.get_ancestors(db, dept_id)


@staticmethod
def delete_dept(db: Session, dept_id: int) -> bool:
    """删除部门"""
    return RbacDao.delete_dept(db, dept_id)
```

### 岗位相关服务方法
```python
@staticmethod
def create_position(db: Session, position_data: Dict[str, Any]) -> SysPosition:
    """创建岗位"""
    # 检查岗位编码是否已存在
    existing_position = db.query(SysPosition).filter(
        SysPosition.position_code == position_data.get("position_code")
    ).first()
    if existing_position:
        raise ValueError(f"岗位编码 {position_data.get('position_code')} 已存在")

    return RbacDao.create_position(db, position_data)


@staticmethod
def update_position(db: Session, position_id: int, update_data: Dict[str, Any]) -> Optional[SysPosition]:
    """更新岗位信息"""
    # 如果更新岗位编码，需要检查是否与其他岗位冲突
    if "position_code" in update_data:
        existing = db.query(SysPosition).filter(
            SysPosition.position_code == update_data["position_code"],
            SysPosition.id != position_id
        ).first()
        if existing:
            raise ValueError(f"岗位编码 {update_data['position_code']} 已存在")

    return RbacDao.update_position(db, position_id, update_data)


@staticmethod
def get_position_by_id(db: Session, position_id: int) -> Optional[SysPosition]:
    """根据ID获取岗位"""
    return RbacDao.get_position_by_id(db, position_id)


@staticmethod
def get_all_positions(db: Session, skip: int = 0, limit: int = 100) -> List[SysPosition]:
    """获取所有岗位"""
    return RbacDao.get_all_positions(db, skip, limit)


@staticmethod
def delete_position(db: Session, position_id: int) -> bool:
    """删除岗位"""
    return RbacDao.delete_position(db, position_id)
```

## 6. 更新API端点

在`app/api/rbac.py`中添加以下路由：

### 部门相关端点
```python
# ===========================================
# 部门管理API - 支持Materialized Path树状结构
# ===========================================

@router.post("/departments", response_model=DeptResponse, summary="创建部门")
async def create_dept(
    dept: DeptCreate,
    db: Session = Depends(get_db)
):
    """创建新部门，自动生成Materialized Path"""
    try:
        dept_obj = RbacService.create_dept(db, dept.model_dump())
        return DeptResponse.model_validate(dept_obj)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"创建部门失败: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="创建部门失败")


@router.get("/departments", response_model=List[DeptResponse], summary="获取所有部门")
async def get_all_depts(
    db: Session = Depends(get_db)
):
    """获取所有部门列表，按路径排序"""
    try:
        depts = RbacService.get_all_depts(db)
        return [DeptResponse.model_validate(dept) for dept in depts]
    except Exception as e:
        logger.error(f"获取部门列表失败: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="获取部门列表失败")


@router.get("/departments/tree", response_model=List[DeptResponse], summary="获取部门树")
async def get_dept_tree(
    db: Session = Depends(get_db)
):
    """获取部门树结构，支持Materialized Path"""
    try:
        depts = RbacService.get_dept_tree(db)
        # 构建树状结构
        dept_map = {dept.id: DeptResponse.model_validate(dept).model_dump() for dept in depts}
        root_depts = []
        
        for dept_id, dept_data in dept_map.items():
            parent_id = dept_data.get("parent_id")
            if parent_id is None:
                # 根部门
                root_depts.append(dept_data)
            else:
                # 添加到父部门的children列表
                if parent_id in dept_map:
                    if "children" not in dept_map[parent_id]:
                        dept_map[parent_id]["children"] = []
                    dept_map[parent_id]["children"].append(dept_data)
        
        return root_depts
    except Exception as e:
        logger.error(f"获取部门树失败: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="获取部门树失败")


@router.get("/departments/{dept_id}", response_model=DeptResponse, summary="获取部门详情")
async def get_dept(
    dept_id: int,
    db: Session = Depends(get_db)
):
    """根据部门ID获取部门详情"""
    try:
        dept = RbacService.get_dept_by_id(db, dept_id)
        if not dept:
            raise HTTPException(status_code=404, detail="部门不存在")
        return DeptResponse.model_validate(dept)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"获取部门详情失败: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="获取部门详情失败")


@router.get("/departments/{dept_id}/descendants", response_model=List[DeptResponse], summary="获取部门子节点")
async def get_dept_descendants(
    dept_id: int,
    db: Session = Depends(get_db)
):
    """获取指定部门的所有子节点（Materialized Path高效查询）"""
    try:
        descendants = RbacService.get_dept_descendants(db, dept_id)
        return [DeptResponse.model_validate(dept) for dept in descendants]
    except Exception as e:
        logger.error(f"获取部门子节点失败: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="获取部门子节点失败")


@router.get("/departments/{dept_id}/ancestors", response_model=List[DeptResponse], summary="获取部门父节点")
async def get_dept_ancestors(
    dept_id: int,
    db: Session = Depends(get_db)
):
    """获取指定部门的所有父节点"""
    try:
        ancestors = RbacService.get_dept_ancestors(db, dept_id)
        return [DeptResponse.model_validate(dept) for dept in ancestors]
    except Exception as e:
        logger.error(f"获取部门父节点失败: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="获取部门父节点失败")


@router.put("/departments/{dept_id}", response_model=DeptResponse, summary="更新部门")
async def update_dept(
    dept_id: int,
    dept_update: DeptUpdate,
    db: Session = Depends(get_db)
):
    """更新部门信息，自动维护Materialized Path"""
    try:
        updated_dept = RbacService.update_dept(db, dept_id, dept_update.model_dump(exclude_unset=True))
        if not updated_dept:
            raise HTTPException(status_code=404, detail="部门不存在")
        return DeptResponse.model_validate(updated_dept)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"更新部门失败: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="更新部门失败")


@router.delete("/departments/{dept_id}", summary="删除部门")
async def delete_dept(
    dept_id: int,
    db: Session = Depends(get_db)
):
    """删除部门，检查是否有子部门"""
    try:
        success = RbacService.delete_dept(db, dept_id)
        if not success:
            raise HTTPException(status_code=404, detail="部门不存在")
        return {"message": "部门删除成功"}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"删除部门失败: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="删除部门失败")
```

## 7. 测试重点

1. **路径生成测试**：创建根部门和子部门，验证路径格式正确
2. **子树查询测试**：使用Materialized Path查询子部门，验证查询结果正确
3. **节点移动测试**：移动部门，验证所有子部门路径更新正确
4. **深度计算测试**：验证部门深度计算正确
5. **树状结构构建测试**：验证API返回的树状结构正确
6. **性能测试**：验证Materialized Path查询性能优于递归查询

## 8. 注意事项

1. **路径完整性**：确保在部门创建、更新、移动时，路径始终保持完整
2. **事务管理**：部门移动时需要使用事务，确保所有子节点路径更新的原子性
3. **索引优化**：为path字段添加索引，优化子树查询性能
4. **边界处理**：处理根部门、叶子节点等特殊情况
5. **错误处理**：添加适当的错误处理，如父部门不存在、子部门存在等情况